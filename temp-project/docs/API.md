APIs Documentation: The following summarizes the key APIs and their roles:
Auth APIs: Endpoints (backed by Cognito/SnapKit) for logging in via Snapchat, TikTok, or Google. On login, if new, create user profile with info from OAuth (e.g., Snapchat gives display name and Bitmoji avatar if permitted). Ensure the OAuth process handles token verification securely. Possibly a separate API to link additional accounts (so a user can connect both Snapchat and TikTok for easier friend finding).

User Profile API: GraphQL queries and mutations to get or update profile info. E.g., getUser(id), updateUser(input). This handles profile visibility settings, username changes, etc. It will enforce that one can only update their own profile (unless admin). Might also include a query like searchUsers(username) if we allow adding friends by username.
Situationship Management API: Mutations like createSituationship(name, category, [photo]), updateSituationship(id, fields), deleteSituationship(id), and perhaps listSituationships(userId) for retrieving a user’s list. This will include the position/rank field. For ranking, we could have a dedicated mutation reorderSituationships(idsInOrder: [ID]!) which the client calls after a drag-and-drop reorder, sending the new sorted list of IDs – the backend will then update each item’s rank index accordingly in one transaction. This keeps the logic simple and on the client side for ordering.

Ranking/Sharing API: (Could be merged with above) – Possibly a convenience query getSituationshipListForShare(userId) that returns the list and maybe a short-lived URL or code to fetch an image for sharing. If we generate images server-side for sharing, an API would handle that (or the client can compose it locally).
Voting/Feedback API: Mutations for friends to submit feedback, e.g., submitVote(targetUserId, bestChoiceId, worstChoiceId, comment) or similar. This will create vote records linked to the target user’s list. There could also be a query getFriendFeedback(targetUserId) that a friend (who has permission) or the user herself uses to retrieve the aggregated results (though the user could just query her own situationships which now have updated vote counts). If anonymity is off, the vote records will include voter’s userId so the owner can see who voted what; if anonymity is on, we might still store the voter but mark it hidden – or we issue the friend a one-time anonymous token for that vote submission so it’s not linked to their userId in the query that the owner sees. We will design this to honor the chosen privacy mode. Additionally, a listInvitableFriends API could help the user see who (from contacts or social connections) is already on the app to invite or who might need an SMS invite.

AI Chat API: Perhaps not a GraphQL but a direct HTTP endpoint (for streaming ease) like /ai/query. However, we can also model it in GraphQL by having a Message type and using subscriptions for responses. Simpler: the app hits an API Gateway endpoint with the user’s message and receives a stream or polling ID. For now, we describe it as: askAI(situationshipId, messageText): AIResponse. The implementation calls the AI model as described. This API will also use an LLM system prompt to keep the AI focused (we will craft a prompt that instructs it to act as a wise, supportive friend and relationship coach, with context about the user’s situation if available).

Block/Report API: Mutations like blockUser(targetUserId) and reportUser(targetUserId, reason) or reportContent(contentId, reason). Blocking will update a relationship table (or a block list attribute on the user). Reporting will create a report entry and possibly trigger an email/alert to admins. We will also expose queries for admins/moderators (internal, not to regular users) to fetch reported content and user info for review. This ensures moderation capabilities as usage grows.

Payment API: While much of the in-app purchase will be handled by Apple/Google SDKs on the client side, we will need backend verification. We can use RevenueCat or simply use our own endpoint to verify receipts. E.g., verifyPurchase(receipt) which our server calls Apple/Google servers to validate and then updates the user’s subscription status in the database (or Cognito attributes). For one-time purchases, similar flow or unlock a feature flag on the user. If using Stripe for any web payments (less likely initially), we’d have webhook handling to grant features. We’ll maintain an Entitlements table or use Cognito user attributes to mark who is premium or who owns which add-on, so the app can check and unlock features accordingly.